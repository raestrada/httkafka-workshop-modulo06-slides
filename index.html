<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<script type="text/template">
						# Workshop Kafka

						> Arquitecturas dirigidas a eventos usando Kafka

						#### **MÓDULO 6:** EDA y Kafka (orientado a MS)
					</script>
				</section>

				<section>
					<section data-markdown data-background-size="contain" data-background-image="https://media.giphy.com/media/3o6ZtirIotBE5zqDtu/giphy.gif">
						<script type="text/template">	
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						
						> Kafka implementa literalmente los conceptos de un EDA. Diferenciemos otros conceptos de alto
						nivel que podrían ser implementados con Kafka, pero no es un EDA.
							
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### Event Sourcing

						Event Sourcing hace referencia a sistemas donde el estado de la aplicación completa es
						almacenado como una secuencia de eventos. Aquí, el termino evento se refiere al
						“cambio de estado”, no es solamente una “notificación”.
						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
						Event-sourcing es un concepto de más alto nivel y más especializado que EDA y Kafka. Ha
						tenido furor con los DDD, pero existe como concepto desde hace tiempo, por ejemplo, en los
						Data Warehouse. 

						> Sus usos pueden ser: estado de la aplicación, revertir eventos, actualizaciones/consultas/interacciones
						externas, control de cambios

						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
						El componente principal de event sourcing es el event-store. Kafka puede ser usado como un
						event-store. En general, como hemos visto, los streams de EDA resuelve varios de los casos de
						uso del event sourcing a través de las particiones. Más adelante vamos a ver las transacciones
						que lo complementan aún  más.

						> En EDA el event-sourcing está en el contexto de una aplicación o micro-servicio. Usar Kafka sólo
						para implementar en ese contexto, no tiene mucho sentido. [Apache bookkeeper](https://bookkeeper.apache.org/) es una mejor solución
						para un event-store 

						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### CQRS

						Command Query Responsability Segregation (CQRS) es un patrón por el cual se tienen estructuras
						de datos separadas para leer y escribir información. CQRS no tiene que ver estrictamente con eventos,
						ya que se puede implementar sin hacer uso de ellos, pero es bastante común que se combine CQRS con
						Event Sourcing.
							
						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
						> CQRS no es "event-first" y es un anti-patrón en una arquitectura EDA.

						CQRS puede ser implementado con Kafka si se usan event-commands y Kafka como
						event store. En mi opinión, esto viola el principio EDA y el uso pensado para KAfka.
							
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### EDA Y Kafka son "Event-First"

						> Un elemento clave de la notificación de eventos es que al sistema de origen no le importa mucho
						la respuesta. A menudo no espera ninguna respuesta, o si hay una respuesta que le importa a la 
						fuente, es indirecta. - _Martin Fowler_
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						- **Event-First:** Entro en una habitación, genero un evento de "habitación entrada" y la 
						luz se enciende. Esta es una reacción a un evento.

						- **Event-Command:** Entro en una habitación, enciendo el interruptor de la luz y la luz se enciende.
						Este es un comando.
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### DDD

						Una forma de trabajar con micro-servicios y equipo es diseñar orientado a los dominios de negocios

						> El concepto más importante el el lenguaje común o lenguaje ubicuo, se debe usar el mismo lenguaje
						en todo el producto, des el usuario final hasta el código y las bases de datos.

						* Notar que el lenguaje es ubicuo dentro del mismo dominio, esto tiene un impacto importante
						en la ventaja del uso de EDA y Kafka para micro-servicios.

						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						Un Micro-Servicio implemente un bounded-context dentro de un sub-dominio. Los micro-servicios
						son diseñados a través de "capacidades de negocio".

						![ddd_process](imgs/ddd-process.png)

						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
						### Bounded context

						El concepto de contexto acotado se originó en los círculos de diseño impulsado por dominio (DDD).
						Promueve un enfoque de modelo de objeto en primer lugar para un servicio,
						definiendo un modelo de datos del que un servicio es responsable y al que está "vinculado".
						En otras palabras, el servicio es propietario de estos datos y es responsable de su integridad y
						mutabilidad.

						> Ojo, el servicio está a cargo de su MUTABILIDAD
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
						![ddd-domain-examples](imgs/ddd-domain-examples.svg)	
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
						![ddd-bounded-context](imgs/ddd-bounded-context.svg)	
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						El/Los micro-servicio/s asociados a un bounded context son los únicos responsables
						de su mutabilidad.

						Acá comienzan los problemas:

						- ¿Qué sucede si otro MS de otro bounded context necesita cambiar/leer datos?

						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### Se complica un poco más

						En DDD y MS, es buena práctica persistir sólo los datos que son necesarios y dado
						que es obligatorio respetar el lenguaje ubicuo, es factible y deseable que una misma
						entidad tenga diferentes nombre y diferentes atributos dependiendo de su dominio.

						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
						### Ejemplo

						En un sistema de reclutamiento, la misma persona es llamada candidato en el dominio
						de reclutamiento y luego es llamado colaborador en el dominio de gestión de personal.
						Ambos tienen como atributo el rut y el CV, pero el colaborador tiene como atributo un
						contrato, el cuál no existe en el candidatos. Además, algunos atributos son diferentes.
						Como candidato usa su mail personal, pero como colaborador, su mail corporativo.

						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### La primera solución: RPC (REST, gRPC, SOAP, etc)

						La solución más común es exponer endpoints en cada MS para permitir mutaciones y lecturas
						desde otros sistemas.

						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### La primera solución: RPC (REST, gRPC, SOAP, etc)

						Esto trae varios problemas:

						- No se puede predecir con cuantos servicios necesitas comunicarse
						- Se generan alto acoplamiento
						- ¿Qué sucede si un servicio no está disponible?
						- ¿Qué sucede con las transacciones que involucran más de un MS en el mismo dominio?
						- No se puede predecir que información puede ser necesitada en el futuro en forma retroactiva.

						</script>
					</section>
					<section>
						<img src="imgs/microservice-rest.png"  height="600" width="600">
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### Segunda solución: Usar asincronismo (Pub/Sub)

						Mejor, pero todavía existen problemas:

						- ¿Qué sucede si un servicio no está disponible?
						- ¿Qué sucede con las transacciones que involucran más de un MS en el mismo dominio?
						- No se puede predecir que información puede ser necesitada en el futuro en forma retroactiva

						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							![microservice-pubsub](imgs/microservice-pubsub.png)	
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### Solución EDA/Kafka

						Para usar EDA y Kafka para comunicación entre micro-servicios, ampliemos la definición<nav>
						de eventos:

						> "Evento de Dominio es un hecho que cambia el estado de una o más entidades
						en forma permanente e inmutable y cambio nuestra percepción del dominio
						dentro del bounded context"

						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### Solución EDA/Kafka

						Tomada esta definición, podemos usar EDa y Kafka y podemos resolver la mayoría de los inconvenientes.
						Se debe tener en consideración:


						- El orden se garantiza por partición:
							* Todos los eventos relacionados deben tener una llave en común
							* Todas los eventos de entidades relacionadas deben ir en el mismo tópico

						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
						### Solución EDA/Kafka
						
						> No es mala práctica crear un tópico por bounded context. Si las entidades son muchas,
						se debería revisar la definición de los bounded context en vez de separar entidades.

						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							![microservice-kafka](imgs/microservice-kafka.png)	
						</script>
					</section>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
