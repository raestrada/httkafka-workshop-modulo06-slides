<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<script type="text/template">
						# Workshop Kafka

						> Arquitecturas dirigidas a eventos usando Kafka

						#### **MÓDULO 5:** Semánticas de entrega
					</script>
				</section>

				<section>
					<section data-markdown data-background-image="https://media.giphy.com/media/r2MkQEOe7niGk/giphy.gif">
						<script type="text/template">
						
						# Garantía de entrega
							
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						
						### Garantía de entrega (letra chica)

						> Kafka garantiza el orden en una partición, pero el orden lo garantiza según el **offset**,
						no según la llave como se podría esperar.

						La garantía de entrega es un concepto muy complejo en sistemas distribuidos. Incluso en sistemas,
						monolíticos como colas tradicionales, se puede garantizar la unicidad y la entrega en el servidor, pero
						no con el cliente. 
							
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						
						### Las fallas ocurren y las operaciones distribuidas no son atómicas

						En kafka interactúan el producer, broker y el consumer. El broker garantiza las operaciones que
						ocurren en el broker, como la escritura o la lectura, pero no puede garantizar errores que ocurren
						antes que la solicitud llegué al broker.
							
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
							### Caso más simple: Fallas en el consumidor

							El consumidor sabe exactamente cuáles son los mensajes que ha leído a través del offset.
							Incluso kafka, almacena en un tópico el último offset leído por grupo de consumidores. 
	
							> El problema es que leer es diferente de procesar. Cada Consumidor reacciona a un evento y potencialmente
							genera un cambio de estado.
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### ¿Como leer eventos?

						Básicamente existen 2 alternativas:

						1. Leer el evento y confirmar como leído y luego generar el cambio de estado
						2. Leer el evento, generar el cambio de estado y luego confirmar como leído.
						
						En el caso 1, el consumidor se puede caer antes de generar el cambio estado y el cambio
						nunca ocurre. En el caso 2, el consumidor se puede caer antes de confirmar el cambio de estado
						y el cambio de estado puede ser generado 2 o más veces.
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
						### ¿Como leer eventos?

						En general, se prefiere el caso 2, debido a que usualmente es más grave nunca procesar un evento.
						La primera alternativa es en el consumidor generar una lectura/escritura atómica.

						> Esto depende de la calidad del código implementado en el servidor.
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
						El punto más crítico es donde se confirma el offset. Si se confía en Kafka, tener en cuenta que
						la mayoría de los clientes no confirmar con zookeeper en forma inmediata para no afectar el desempeño,
						es decir, existe una ventana de una decena/centena de ms dónde incluso con un código correcto, podrían
						existir duplicaciones. 
			
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
						> En vez de confiar en Kafka, se puede usar un sistema de estado atómico como Redis o etc,
						claro que el problema es el mismo. Sólo mejora un poco debido a que estos sistemas son más eficientes
						para este tipo de acción.

						Kafka 3 va a eliminar Zookeeper. Muchos de los problemas de latencia en la sincronización de estado,
						son causados por Zookeeeper.
		
						</script>
					</section>
				</section>
				<section>
					<section data-markdown>
						<script type="text/template">
						### El productor también presenta los mismo problemas
						
						El productor también puede fallar en recibir la confirmación del broker y duplicar los eventos.

						> Incluso aunque el consumidor no falle, aún así podría recibir eventos duplicados y seguir
						presentando problemas.
		
						</script>
					</section>
				</section>
				<section>
					<section data-markdown>
						<script type="text/template">
						### Es hora de habla de semánticas de entrega
						
						Existen 3 forma de entrega:

						- At least once
						- At most once
						- Exactly once

						#### **Material basado en este [post](https://medium.com/@sdjemails/kafka-producer-delivery-semantics-be863c727d3f)**
						</script>
					</section>
				</section>
				<section>
					<section data-markdown>
						<script type="text/template">
						### At Most once
						
						> Cada evento es recibido a lo más una vez y puede no ser recibido nunca. Es aceptable
						perder algunos eventos sobre procesar un evento 2 veces.

						Caso de uso son por ejemplo, recolección de métricas. At most Once no es uno de los mejores casos
						de uso de Kafka, aunque si es cierto que con esta semántica se puede alcanzar un throughput impresionante.
						</script>
					</section>
					<section data-markdown data-background-color="aquamarine">
						<script type="text/template">
						![at-most-once](imgs/at-most-once.png)
						</script>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
